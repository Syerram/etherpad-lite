var settings = require('ep_etherpad-lite/node/utils/Settings');
var authorManager = require("ep_etherpad-lite/node/db/AuthorManager");
var log4js = require('ep_etherpad-lite/node_modules/log4js');
var string = require("string");
var url  = require('url');

var auth_log = log4js.getLogger("ep_auth");

function get_note_meta(base64_encoded_value) {
  note_meta = new Buffer(base64_encoded_value, 'base64');
  return JSON.parse(note_meta);  
}
/**
Does simple cookie based validation. 
1. checks for 'kh.sessionid'. if present, then 
2. checks for 'note_meta'. if present then
3. compares the title of the pad against the url submitted. if it mactches, then returns true, else false

ASSUMPTION: It assumes they are on the same domain or subdomain
*/
exports.authenticate = function (hook_name, context, cb) {
  auth_log.debug('auth_check underway....');
  if(!(context.req.session && context.req.session.user)) {
    if(!context.req.cookies || !context.req.cookies['kh.sessionid']) {
      auth_log.info('no "kh.sessionid" was found. exiting');
      cb([false]);
      return;
    } else {
      if(!context.req.cookies['note_meta']) {
        auth_log.info('no "note_meta" was found. exiting');
        cb([false]);
        return;
      }
      note_meta = get_note_meta(context.req.cookies['note_meta']);
      if(string(context.req.path).endsWith(note_meta['slug'])) {
        auth_log.debug('slugs matched: setting session to user %s', note_meta['user']);
        context.req.session.user = {'username':  note_meta['user'], 'is_admin': false, 'password': '' };
      } else {
        auth_log.info('slug cookie %s mismatch with the url slug %s', note_meta['slug'], context.req.path);
        cb([false]);
        return;
      }
    }
  }
  cb([true]);
}

/**
Auth failure redirects the user to KH url for auth failure.
We do not try to attempt to have user login bcoz its obvious that the user tired to access this differently

*/
exports.authFailure = function (hook_name, context, cb) {
    auth_log.info('auth_failure. redirecting user to %s', settings.ep_auth.auth_failure);
    context.res.redirect(settings.ep_auth.auth_failure);
}

/**
  Helper method to update the current username to the session name set by the cookie_auth handler
*/
function setUserName(token, session) {
  authorManager.getAuthor4Token(token, function(err, author) {
    if(err) {
      auth_log.info('error occured %s', token);
      return;
    } else {
      authorManager.setAuthorName(author, session.user.username);
      auth_log.debug('updated username to %s', session.user.username);
    }
  });
  return;
}

/**
handler that updates username to the session username.
unauthorized user updates will be disallowed
TODO: add authorization so we can check user is logged in
*/
exports.handleMessage = function(hook_name, context, cb) {
  if(context.message.type === "CLIENT_READY") {
    try {
      session = context.client.manager.handshaken[context.client.id].session;
      
      var note_meta = get_note_meta(context.client.manager.handshaken[context.client.id].cookies['note_meta']);
      var referrer_url = url.parse(context.client.manager.handshaken[context.client.id].headers['referer'], true);

      if(string(referrer_url.pathname).endsWith(note_meta['slug'])) {
        //set the session back just in case
        session.user = {'username':  note_meta['user'], 'is_admin': false, 'password': '' };

        setUserName(context.message.token, session);
        auth_log.debug('slugs DO match. note_meta %s and url %s', note_meta['slug'], referrer_url.pathname);
      } else {
        auth_log.info('slugs do not match. note_meta %s and url %s', note_meta['slug'], referrer_url.pathname);
        return cb(null);
      }
    } catch (e) {
      auth_log.info("exception occured while set username");
      auth_log.info(e);
      return cb(null);
    }
  }
  return cb([]);
}
